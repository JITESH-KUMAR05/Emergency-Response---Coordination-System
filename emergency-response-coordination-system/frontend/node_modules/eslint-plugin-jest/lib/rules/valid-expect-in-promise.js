"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

var _utils = require("./utils");

const isPromiseChainCall = node => {
  if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property)) {
    // promise methods should have at least 1 argument
    if (node.arguments.length === 0) {
      return false;
    }

    switch ((0, _utils.getAccessorValue)(node.callee.property)) {
      case 'then':
        return node.arguments.length < 3;

      case 'catch':
      case 'finally':
        return node.arguments.length < 2;
    }
  }

  return false;
};

const findTopMostCallExpression = node => {
  let topMostCallExpression = node;
  let {
    parent
  } = node;

  while (parent) {
    if (parent.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {
      topMostCallExpression = parent;
      parent = parent.parent;
      continue;
    }

    if (parent.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {
      break;
    }

    parent = parent.parent;
  }

  return topMostCallExpression;
};

const isTestCaseCallWithCallbackArg = node => {
  if (!(0, _utils.isTestCaseCall)(node)) {
    return false;
  }

  const isJestEach = (0, _utils.getNodeName)(node).endsWith('.each');

  if (isJestEach && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression) {
    // isJestEach but not a TaggedTemplateExpression, so this must be
    // the `jest.each([])()` syntax which this rule doesn't support due
    // to its complexity (see jest-community/eslint-plugin-jest#710)
    // so we return true to trigger bailout
    return true;
  }

  if (isJestEach || node.arguments.length >= 2) {
    const [, callback] = node.arguments;
    const callbackArgIndex = Number(isJestEach);
    return callback && (0, _utils.isFunction)(callback) && callback.params.length === 1 + callbackArgIndex;
  }

  return false;
};

const isPromiseMethodThatUsesValue = (node, identifier) => {
  const {
    name
  } = identifier;

  if (node.argument === null) {
    return false;
  }

  if (node.argument.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.argument.arguments.length > 0) {
    const nodeName = (0, _utils.getNodeName)(node.argument);

    if (['Promise.all', 'Promise.allSettled'].includes(nodeName)) {
      const [firstArg] = node.argument.arguments;

      if (firstArg.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && firstArg.elements.some(nod => (0, _utils.isIdentifier)(nod, name))) {
        return true;
      }
    }

    if (['Promise.resolve', 'Promise.reject'].includes(nodeName) && node.argument.arguments.length === 1) {
      return (0, _utils.isIdentifier)(node.argument.arguments[0], name);
    }
  }

  return (0, _utils.isIdentifier)(node.argument, name);
};
/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed within the given array of elements
 */


const isValueAwaitedInElements = (name, elements) => {
  for (const element of elements) {
    if (element.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && (0, _utils.isIdentifier)(element.argument, name)) {
      return true;
    }

    if (element.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && isValueAwaitedInElements(name, element.elements)) {
      return true;
    }
  }

  return false;
};
/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed as an argument along the given call expression
 */


const isValueAwaitedInArguments = (name, call) => {
  let node = call;

  while (node) {
    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {
      if (isValueAwaitedInElements(name, node.arguments)) {
        return true;
      }

      node = node.callee;
    }

    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {
      break;
    }

    node = node.object;
  }

  return false;
};

const getLeftMostCallExpression = call => {
  let leftMostCallExpression = call;
  let node = call;

  while (node) {
    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {
      leftMostCallExpression = node;
      node = node.callee;
    }

    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {
      break;
    }

    node = node.object;
  }

  return leftMostCallExpression;
};
/**
 * Attempts to determine if the runtime value represented by the given `identifier`
 * is `await`ed or `return`ed within the given `body` of statements
 */


const isValueAwaitedOrReturned = (identifier, body) => {
  const {
    name
  } = identifier;

  for (const node of body) {
    // skip all nodes that are before this identifier, because they'd probably
    // be affecting a different runtime value (e.g. due to reassignment)
    if (node.range[0] <= identifier.range[0]) {
      continue;
    }

    if (node.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement) {
      return isPromiseMethodThatUsesValue(node, identifier);
    }

    if (node.type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement) {
      // it's possible that we're awaiting the value as an argument
      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {
        if (isValueAwaitedInArguments(name, node.expression)) {
          return true;
        }

        const leftMostCall = getLeftMostCallExpression(node.expression);

        if ((0, _utils.isExpectCall)(leftMostCall) && leftMostCall.arguments.length > 0 && (0, _utils.isIdentifier)(leftMostCall.arguments[0], name)) {
          const {
            modifier
          } = (0, _utils.parseExpectCall)(leftMostCall);

          if ((modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.resolves || (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.rejects) {
            return true;
          }
        }
      }

      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && isPromiseMethodThatUsesValue(node.expression, identifier)) {
        return true;
      } // (re)assignment changes the runtime value, so if we've not found an
      // await or return already we act as if we've reached the end of the body


      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AssignmentExpression) {
        var _getNodeName;

        // unless we're assigning to the same identifier, in which case
        // we might be chaining off the existing promise value
        if ((0, _utils.isIdentifier)(node.expression.left, name) && (_getNodeName = (0, _utils.getNodeName)(node.expression.right)) !== null && _getNodeName !== void 0 && _getNodeName.startsWith(`${name}.`) && isPromiseChainCall(node.expression.right)) {
          continue;
        }

        break;
      }
    }

    if (node.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement && isValueAwaitedOrReturned(identifier, node.body)) {
      return true;
    }
  }

  return false;
};

const findFirstBlockBodyUp = node => {
  let parent = node;

  while (parent) {
    if (parent.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {
      return parent.body;
    }

    parent = parent.parent;
  }
  /* istanbul ignore next */


  throw new Error(`Could not find BlockStatement - please file a github issue at https://github.com/jest-community/es